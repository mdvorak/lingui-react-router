# Lingui React Router Architecture

This project provides integration between Lingui and React Router, offering locale-aware routing,
server middleware, and a streamlined client bootstrap for Server-Side Rendered (SSR) applications.

## Project Structure

The project is a monorepo managed with pnpm workspaces.

- `src/`: Contains the source code for the `lingui-react-router` library.
  - `client/`: Client-side specific logic.
  - `server/`: Server-side specific logic, including middleware for locale negotiation.
  - `components/`: Reusable React components like `I18nApp` and `LocaleLink`.
  - `test/`: Contains test utilities to test the localized applications.
  - `plugin/`: Vite plugin for this library.
- `test/`: Contains a React Router application used for testing the library. This is not part of the
  main library but is used for integration and end-to-end testing.

## Key Technologies and Libraries

- **Lingui:** A modern internationalization (i18n) library for JavaScript projects.
- **React Router:** A standard library for routing in React applications.
- **Vite:** A fast build tool and development server.
- **pnpm:** A fast, disk space-efficient package manager.
- **TypeScript:** The project is written entirely in TypeScript.
- **Vitest:** A fast unit test framework powered by Vite.

## Patterns

- **Monorepo:** The project uses a monorepo structure to manage the library and its test application
  in a single repository.
- **SSR (Server-Side Rendering):** The library is designed to work with SSR applications, providing
  utilities for both client and server environments.
- **Vite Plugin:** The project includes a Vite plugin to simplify the integration with Vite-based
  projects.
- **Macros:** The library uses babel macros (`@lingui/react/macro`) for compile-time
  transformations, which helps in optimizing the final bundle.

## Testing

- **Unit Tests:** Unit tests are written with Vitest and are located next to the source files (e.g.,
  `*.test.ts`).
- **Integration Tests:** The `test/` directory contains a full React Router application that serves
  as an integration test for the library. It has its own `package.json` and dependencies. This
  application is used to test the library in a real-world scenario.
- **E2E Tests:** The test application in the `test/` directory can be used for end-to-end testing of
  the library's features.

## Library Architecture

The `lingui-react-router` library is composed of two main parts that work in concert: a Vite plugin
for build-time operations and a runtime component for client and server logic.

### Vite Plugin (`linguiRouterPlugin`)

The plugin is the core of the library's "magic." It automates the process of setting up
locale-based code splitting and data loading. Its primary responsibility is to generate several
**virtual modules** that the runtime part of the library can then consume.

- **Virtual Module Generation**: The plugin doesn't write files to disk. Instead, it intercepts
  requests for specific module IDs (e.g., `virtual:lingui-router/loader`) and provides their
  content on the fly.
- **`virtual:lingui-router/locale/{locale}`**: For each locale defined in your
  `lingui.config.js` (like `en`, `cs`), the plugin generates a module. This module contains the
  compiled message catalogs loaded from your `.po` files. During the build process, Vite and
  Rollup automatically split these virtual modules into their own JavaScript chunks (e.g.,
  `locale-en.js`, `locale-cs.js`).
- **`virtual:lingui-router/manifest`**: This module contains a manifest, which is a JSON object
  that maps each locale ID to the URL of its corresponding JavaScript chunk. The runtime uses this
  to know which file to fetch for a given locale.
- **`virtual:lingui-router/loader`**: This acts as the main interface for the runtime. It exports
  functions that use the `manifest` to dynamically import the correct locale chunk and initialize
  the Lingui i18n instance with the messages.

> **Note:** These virtual modules are for internal use by the `lingui-react-router` library only and
> should not be imported or used directly in your application code.

### Runtime (`lingui-react-router`, `lingui-react-router/server`, `lingui-react-router/client`)

This is the code that executes in the browser and on the server during SSR. It's designed to work
seamlessly with the virtual modules generated by the plugin.

- **Server-Side (`src/server/`)**: On the server, a middleware inspects incoming requests to
  determine the user's preferred locale (from the URL or `Accept-Language` header). It then uses
  the `loader` virtual module to load the appropriate messages directly. This ensures the initial
  server-rendered HTML is already translated. Context is available in the loaders and actions
  via the `useLinguiServer` hook.
- **Client-Side (`src/client/`)**: In the browser, the client-side initialization script
  determines the current locale. It then uses the `manifest` and `loader` virtual modules to fetch
  the correct message catalog chunk if it's not already loaded. This is done before the React
  application hydrates to prevent any flash of untranslated content.
- **Components (`src/components/`)**:
  * `I18nApp`: This React component wraps your application. It orchestrates the i18n
    initialization on both server and client, ensuring a smooth and flicker-free hydration
    process.
  * `LocaleLink`: A component that automatically prefixes `to` paths with the currently active
    locale, simplifying the creation of locale-aware navigation links.
  * `LocalePreload`: A component that preloads the current locale's message catalog chunk during
    page load. Used only during SSR, it's no-op on the client.

### How It Fits Together

1. At **build time**, the Vite plugin prepares all the necessary locale data, splitting it into
   separate, loadable chunks and creating virtual modules to act as an interface.
2. During a **server-side request**, the middleware detects the locale, loads the messages for that
   locale directly, and renders the translated HTML.
3. When the page loads in the **browser**, the client runtime uses the manifest to fetch the
   messages for the active locale (if needed) and hydrates the React application with the i18n
   context fully prepared.

This architecture provides an efficient, automated i18n solution that integrates deeply with the
build process to optimize the final application bundle and provide a seamless experience for both
developers and end-users.

